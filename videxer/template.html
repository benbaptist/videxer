<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Media Library Index</title>
  <style>
  /* ========================================
     CSS Variables & Reset
     ======================================== */
  :root { 
    color-scheme: dark;
    --bg: #0a0a0a;
    --bg-gradient: linear-gradient(135deg, #0a0a0a 0%, #111111 100%);
    --panel: rgba(20, 20, 20, 0.6);
    --nav: rgba(15, 15, 15, 0.7);
    --card: rgba(25, 25, 25, 0.5);
    --border: rgba(255, 255, 255, 0.06);
    --muted: #888888;
    --text: #e8e8e8;
    --accent: #60a5fa;
    --shadow: rgba(0, 0, 0, 0.5);
    --glass-blur: blur(20px);
    --sidebar-width: 320px;
    --spacing: 20px;
  }

  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  html { height: 100%; }
  body { 
    font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; 
    min-height: 100%;
    background: var(--bg);
    background-image: var(--bg-gradient);
    background-attachment: fixed;
    color: var(--text);
    overflow-x: hidden;
  }

  /* ========================================
     App Layout - Mobile First
     ======================================== */
  .app { 
    display: flex;
    flex-direction: column;
    min-height: 100vh;
  }

  /* Mobile: nav at top */
  nav.nav { 
    flex-shrink: 0;
    background: var(--nav); 
    backdrop-filter: var(--glass-blur);
    -webkit-backdrop-filter: var(--glass-blur);
    padding: var(--spacing);
    z-index: 10;
    box-shadow: 0 8px 32px var(--shadow);
    margin: var(--spacing) var(--spacing) 0;
    border-radius: 24px;
  }

  .main { 
    flex: 1;
    min-width: 0;
    padding: var(--spacing);
  }

  /* Desktop: sidebar layout */
  @media (min-width: 1024px) {
    .app { 
      flex-direction: row;
      height: 100vh;
      overflow: hidden;
    }
    
    nav.nav { 
      width: var(--sidebar-width);
      flex-shrink: 0;
      height: calc(100vh - var(--spacing) * 2);
      margin: var(--spacing) 0 var(--spacing) var(--spacing);
      overflow-y: auto;
    }
    
    .main {
      flex: 1;
      overflow-y: auto;
    }
  }

  /* ========================================
     Navigation Components
     ======================================== */
  .brand { display: flex; align-items: center; gap: 10px; margin-bottom: 12px; }
  .brand-title { font-weight: 800; letter-spacing: .3px; font-size: 20px; }
  .controls { display: grid; gap: 10px; }
  .controls .row { display: flex; gap: 8px; flex-wrap: wrap; }

  /* ========================================
     Form Elements
     ======================================== */
  .input, .select, .btn { 
    padding: 12px 16px; 
    font-size: 14px; 
    border: none;
    border-radius: 16px; 
    background: var(--panel);
    backdrop-filter: var(--glass-blur);
    -webkit-backdrop-filter: var(--glass-blur);
    color: var(--text);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  }
  .btn { 
    cursor: pointer; 
    user-select: none; 
    text-decoration: none; 
    transition: all 0.3s ease;
  }
  .btn:hover { 
    background: rgba(40, 40, 40, 0.7);
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
    transform: translateY(-1px);
  }
  .hint { font-size: 12px; color: var(--muted); margin-left: 2px; }
  .input:focus, .select:focus, .btn:focus { 
    outline: 2px solid rgba(96, 165, 250, 0.5); 
    outline-offset: 2px; 
  }

  /* ========================================
     Content Grid
     ======================================== */
  .container { 
    display: grid; 
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); 
    gap: var(--spacing); 
    max-width: 1800px; 
    margin: 0 auto; 
  }
  .container.list { 
    display: flex;
    flex-direction: column;
    gap: var(--spacing);
  }

  /* ========================================
     Breadcrumb
     ======================================== */
  .breadcrumb { 
    display: flex; 
    align-items: center; 
    flex-wrap: wrap; 
    gap: 8px; 
    padding-bottom: 16px; 
    margin-bottom: 16px; 
  }
  .breadcrumb-item { 
    padding: 8px 14px; 
    font-size: 13px;
    border-radius: 12px;
  }
  .breadcrumb-sep { color: var(--muted); font-size: 12px; }

  /* ========================================
     Cards
     ======================================== */
  .card { 
    background: var(--card);
    backdrop-filter: var(--glass-blur);
    -webkit-backdrop-filter: var(--glass-blur);
    border-radius: 20px; 
    overflow: hidden; 
    display: flex; 
    flex-direction: column; 
    transition: box-shadow 0.3s ease;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
  }
  .card:hover { 
    box-shadow: 0 12px 40px rgba(0, 0, 0, 0.6);
  }

  .directory-media { 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    aspect-ratio: 16/9;
    background: linear-gradient(135deg, rgba(30, 30, 30, 0.4) 0%, rgba(40, 40, 40, 0.4) 100%);
    backdrop-filter: var(--glass-blur);
    -webkit-backdrop-filter: var(--glass-blur);
  }
  .directory-icon { color: var(--accent); opacity: 0.6; transition: opacity 0.3s ease; }
  .directory-media:hover .directory-icon { opacity: 1; }

  .media { 
    position: relative; 
    display: block; 
    padding: 0; 
    border: 0; 
    background: transparent; 
    cursor: pointer; 
    overflow: hidden; 
    border-radius: 20px 20px 0 0; 
  }
  .thumb { width: 100%; aspect-ratio: 16/9; object-fit: contain; background: #0a0a0a; display: block; }
  .motion-thumb { 
    width: 100%; 
    height: 100%; 
    object-fit: contain; 
    background: #0a0a0a; 
    position: absolute; 
    top: 0; 
    left: 0; 
    opacity: 0; 
    pointer-events: none; 
    transition: opacity .2s ease; 
  }
  .play { 
    position: absolute; 
    inset: 0; 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    background: linear-gradient(180deg, rgba(0,0,0,0) 40%, rgba(0,0,0,0.5) 100%); 
    opacity: 0; 
    transition: opacity .3s; 
  }
  .media:hover .play { opacity: 1; }
  .play-icon { 
    width: 64px; 
    height: 64px; 
    border-radius: 50%; 
    background: rgba(0, 0, 0, 0.6);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 2px solid rgba(255, 255, 255, 0.2); 
    display: grid; 
    place-items: center;
    transition: all 0.3s ease;
  }
  .media:hover .play-icon {
    transform: scale(1.1);
    background: rgba(0, 0, 0, 0.7);
  }
  .play-icon svg { width: 24px; height: 24px; fill: #fff; transform: translateX(2px); }
  
  .content { padding: 16px; display: flex; flex-direction: column; gap: 10px; }
  .title { font-size: 14px; font-weight: 600; }
  .title button { background: none; border: 0; color: var(--text); font: inherit; cursor: pointer; padding: 0; }
  .title button:hover { text-decoration: underline; }
  .meta { font-size: 12px; color: var(--muted); display: flex; gap: 8px; flex-wrap: wrap; }
  .badge { 
    background: rgba(40, 40, 40, 0.6);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-radius: 12px; 
    padding: 4px 10px;
  }
  .row .btn { background: transparent; }

  /* List view overrides */
  .container.list .card { flex-direction: row; align-items: stretch; }
  .container.list .media { width: 260px; min-width: 260px; border-radius: 20px 0 0 20px; }
  .container.list .directory-media { aspect-ratio: 16/9; }
  .container.list .thumb { width: 100%; height: 100%; aspect-ratio: unset; object-fit: contain; }
  .container.list .content { flex: 1; }

  /* ========================================
     Accessibility
     ======================================== */
  .visually-hidden { 
    position: absolute !important; 
    width: 1px; 
    height: 1px; 
    padding: 0; 
    margin: -1px; 
    overflow: hidden; 
    clip: rect(0, 0, 0, 0); 
    white-space: nowrap; 
    border: 0; 
  }

  /* ========================================
     Modal Player (fallback for unsupported)
     ======================================== */
  .modal { 
    position: fixed; 
    inset: 0; 
    display: none; 
    align-items: center; 
    justify-content: center; 
    background: rgba(0, 0, 0, 0.85); 
    backdrop-filter: blur(10px); 
    -webkit-backdrop-filter: blur(10px); 
    z-index: 50; 
  }
  .modal.open { display: flex; }
  .modal-dialog { 
    width: min(90vw, 1200px); 
    background: var(--card);
    backdrop-filter: var(--glass-blur);
    -webkit-backdrop-filter: var(--glass-blur);
    border-radius: 24px; 
    overflow: hidden; 
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
  }
  .modal-header { 
    display: flex; 
    justify-content: space-between; 
    align-items: center; 
    padding: 16px 20px; 
    background: rgba(20, 20, 20, 0.6);
  }
  .modal-title { font-size: 15px; font-weight: 600; }
  .modal-close { 
    background: rgba(40, 40, 40, 0.6);
    border: none;
    border-radius: 12px;
    color: var(--text); 
    font-size: 24px; 
    cursor: pointer;
    padding: 4px 12px;
    line-height: 1;
    transition: all 0.3s ease;
  }
  .modal-close:hover { background: rgba(60, 60, 60, 0.8); }
  .modal-body { background: #000; }
  video, audio { display: block; width: 100%; height: auto; background: #000; }
  img.modal-image { display: block; max-width: 100%; max-height: 80vh; margin: 0 auto; }

  /* ========================================
     Immersive Player - Mobile First
     ======================================== */
  body.immersive-open { overflow: hidden; }
  
  .immersive { 
    position: fixed; 
    inset: 0; 
    z-index: 60; 
    display: none; 
    flex-direction: column;
    background: var(--bg); 
    color: var(--text);
    overflow: hidden;
  }
  .immersive.open { display: flex; }
  
  .immersive-header { 
    flex-shrink: 0;
    height: 60px;
    display: flex; 
    align-items: center; 
    gap: 12px; 
    padding: 14px 18px; 
    background: #000;
  }
  .immersive-title { 
    font-size: 17px; 
    font-weight: 600; 
    flex: 1; 
    overflow: hidden; 
    text-overflow: ellipsis; 
    white-space: nowrap; 
  }
  .immersive-close { 
    background: rgba(40, 40, 40, 0.8);
    border: none;
    border-radius: 14px; 
    color: var(--text); 
    padding: 10px 16px; 
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 15px;
  }
  .immersive-close:hover { background: rgba(60, 60, 60, 0.9); }
  
  .quality { display: flex; gap: 8px; align-items: center; }
  .quality .btn { padding: 10px 14px; font-size: 14px; }
  .quality .btn.active { 
    background: rgba(96, 165, 250, 0.25);
    box-shadow: 0 0 0 2px rgba(96, 165, 250, 0.5);
  }
  
  .immersive-content { 
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }
  
  .immersive-media { 
    flex-shrink: 0;
    width: 100%; 
    background: #000; 
    aspect-ratio: 16/9;
    max-height: 50vh;
  }
  .immersive-media > video, 
  .immersive-media > img { 
    width: 100%; 
    height: 100%; 
    object-fit: contain; 
    display: block; 
    background: #000; 
  }
  
  .immersive-info { 
    flex: 1;
    overflow-y: auto; 
    padding: var(--spacing); 
    background: var(--bg);
  }
  .immersive .meta { margin-top: 8px; }
  .immersive .row { margin-top: 8px; }
  
  /* Desktop: player alongside sidebar */
  @media (min-width: 1024px) {
    .immersive { 
      left: calc(var(--sidebar-width) + var(--spacing));
      z-index: 5;
    }
    
    .immersive-header {
      margin: var(--spacing) var(--spacing) 0 0;
      border-radius: 24px 24px 0 0;
      background: var(--nav);
      backdrop-filter: var(--glass-blur);
      -webkit-backdrop-filter: var(--glass-blur);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    }
    
    .immersive-content { 
      margin: 0 var(--spacing) var(--spacing) 0;
      border-radius: 0 0 24px 24px;
      background: var(--card);
      backdrop-filter: var(--glass-blur);
      -webkit-backdrop-filter: var(--glass-blur);
      box-shadow: 0 8px 32px var(--shadow);
    }
    
    .immersive-media { 
      max-height: 55vh;
    }
    
    .immersive-info { 
      display: flex;
      flex-direction: row;
      gap: 0;
      padding: 0;
      background: transparent;
      overflow: hidden;
    }
    
    .immersive-info > div:first-child {
      flex: 1;
      padding: 24px;
      overflow-y: auto;
    }
  }

  /* ========================================
     Transcript Panel
     ======================================== */
  .transcript-panel {
    margin-top: var(--spacing);
    background: var(--panel);
    backdrop-filter: var(--glass-blur);
    -webkit-backdrop-filter: var(--glass-blur);
    border-radius: 12px;
    overflow: hidden;
  }
  
  .transcript-header {
    padding: 12px 16px;
    border-bottom: 1px solid var(--border);
  }
  
  .transcript-title {
    font-size: 14px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--muted);
  }
  
  .transcript-search {
    padding: 8px 12px;
    border-bottom: 1px solid var(--border);
  }
  
  .transcript-search input {
    width: 100%;
    padding: 6px 10px;
    background: rgba(20, 20, 20, 0.6);
    border: 1px solid var(--border);
    border-radius: 8px;
    color: var(--text);
    font-size: 13px;
    font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
  }
  
  .transcript-search input:focus {
    outline: 2px solid rgba(96, 165, 250, 0.5);
    outline-offset: 2px;
  }
  
  .transcript-body {
    overflow-y: auto;
    max-height: 300px;
  }
  
  .transcript-segments { padding: 4px; }
  
  .transcript-segment {
    display: flex;
    gap: 10px;
    padding: 6px 8px;
    margin-bottom: 2px;
    border-radius: 6px;
    cursor: pointer;
    transition: background 0.15s ease;
    font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
  }
  
  .transcript-segment:hover { background: rgba(40, 40, 40, 0.6); }
  .transcript-segment.active {
    background: rgba(96, 165, 250, 0.15);
    border-left: 2px solid var(--accent);
  }
  .transcript-segment.hidden { display: none; }
  
  .transcript-timestamp {
    flex-shrink: 0;
    color: var(--accent);
    font-size: 12px;
    font-weight: 500;
    min-width: 50px;
    font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
  }
  
  .transcript-text {
    flex: 1;
    font-size: 13px;
    line-height: 1.5;
    color: var(--text);
  }
  
  .transcript-text mark {
    background: rgba(255, 235, 59, 0.3);
    color: var(--text);
    border-radius: 3px;
    padding: 0 2px;
  }
  
  .transcript-empty {
    padding: 40px 20px;
    text-align: center;
    color: var(--muted);
    font-size: 14px;
  }
  
  /* Desktop transcript: side panel */
  @media (min-width: 1024px) {
    .transcript-panel {
      margin-top: 0;
      width: 35%;
      max-width: 450px;
      min-width: 300px;
      background: rgba(15, 15, 15, 0.8);
      border-radius: 0;
      border-left: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      height: 100%;
    }
    
    .transcript-header { padding: 12px 14px; flex-shrink: 0; }
    .transcript-title { font-size: 11px; }
    .transcript-search { padding: 8px 10px; flex-shrink: 0; }
    .transcript-search input { padding: 5px 8px; font-size: 12px; border-radius: 6px; }
    .transcript-body { flex: 1; overflow-y: auto; max-height: none; }
    .transcript-segments { padding: 2px 2px 20px 2px; }
    .transcript-segment { padding: 5px 8px; margin-bottom: 1px; border-radius: 4px; font-size: 12px; line-height: 1.4; }
    .transcript-timestamp { font-size: 11px; min-width: 45px; }
    .transcript-text { font-size: 12px; line-height: 1.4; }
  }
  </style>
  </style>
  <script>
    async function fetchJSON(path) {
      const res = await fetch(path);
      if (!res.ok) throw new Error('Failed to load ' + path);
      return res.json();
    }

  function fmtDate(s) {
      if (!s) return '';
      try { return new Date(s).toLocaleString(); } catch { return s; }
    }

    function fmtSize(bytes) {
      if (bytes == null) return '';
      const units = ['B','KB','MB','GB','TB'];
      let n = Number(bytes);
      let i = 0;
      while (n >= 1024 && i < units.length - 1) { n /= 1024; i++; }
      return n.toFixed(n >= 10 || i === 0 ? 0 : 1) + ' ' + units[i];
    }

    function pickThumb(it) {
      // Prefer explicit best thumbnail if present; else last in thumbs[]
      if (it.thumb_best) return it.thumb_best;
      if (it.thumbs && it.thumbs.length) return it.thumbs[it.thumbs.length - 1];
      return '';
    }

    function getMediaIcon(type) {
      switch(type) {
        case 'video': return '<svg viewBox="0 0 24 24" width="22" height="22"><path d="M8 5v14l11-7z" fill="#fff"></path></svg>';
        case 'audio': return '<svg viewBox="0 0 24 24" width="22" height="22"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z" fill="#fff"></path></svg>';
        case 'image': return '<svg viewBox="0 0 24 24" width="22" height="22"><path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z" fill="#fff"></path></svg>';
        default: return '<svg viewBox="0 0 24 24" width="22" height="22"><path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z" fill="#fff"></path></svg>';
      }
    }

    async function load() {
      const data = await fetchJSON('index.json');
      const container = document.querySelector('.container');
      const search = document.getElementById('search');
      const sortSel = document.getElementById('sort');
      const dirBtn = document.getElementById('direction');
      const viewBtn = document.getElementById('view');
      const breadcrumbEl = document.getElementById('breadcrumb');
      
      let allItems = data.items || [];
      let currentPath = []; // Stack of directory names
      let currentItems = allItems; // Items in current view
      let searchIndex = data.search_index || { subtitle_terms: {}, name_terms: {}, description_terms: {}, item_map: [] };
      let subtitlesLoading = false; // Track if we're already loading subtitles
      let sortKey = 'date'; // alpha | size | date | type
      let sortDir = 'desc'; // asc | desc
      let viewMode = 'grid'; // grid | list

      function updateBreadcrumb() {
        breadcrumbEl.innerHTML = '';
        
        // Root/home button
        const homeBtn = document.createElement('button');
        homeBtn.className = 'breadcrumb-item btn';
        homeBtn.textContent = 'ðŸ  Library';
        homeBtn.addEventListener('click', () => navigateToRoot());
        breadcrumbEl.appendChild(homeBtn);
        
        // Path segments
        currentPath.forEach((dirName, idx) => {
          const sep = document.createElement('span');
          sep.className = 'breadcrumb-sep';
          sep.textContent = ' / ';
          breadcrumbEl.appendChild(sep);
          
          const btn = document.createElement('button');
          btn.className = 'breadcrumb-item btn';
          btn.textContent = dirName;
          btn.addEventListener('click', () => navigateToIndex(idx + 1));
          breadcrumbEl.appendChild(btn);
        });
      }
      
      function navigateToRoot() {
        currentPath = [];
        currentItems = allItems;
        search.value = '';
        window.location.hash = '';
        apply();
      }
      
      function navigateToIndex(pathIndex) {
        // Navigate to a specific depth in the path
        currentPath = currentPath.slice(0, pathIndex);
        
        // Navigate through hierarchy to find current items
        currentItems = allItems;
        for (const dirName of currentPath) {
          const dir = currentItems.find(item => item.type === 'directory' && item.name === dirName);
          if (dir && dir.children) {
            currentItems = dir.children;
          } else {
            // Path not found, go to root
            currentPath = [];
            currentItems = allItems;
            break;
          }
        }
        
        search.value = '';
        updateHash();
        apply();
      }
      
      function navigateInto(dirName) {
        const dir = currentItems.find(item => item.type === 'directory' && item.name === dirName);
        if (dir && dir.children) {
          currentPath.push(dirName);
          currentItems = dir.children;
          search.value = '';
          updateHash();
          apply();
        }
      }
      
      function updateHash() {
        // Update URL hash with current path
        if (currentPath.length === 0) {
          window.location.hash = '';
        } else {
          window.location.hash = '#' + currentPath.map(encodeURIComponent).join('/');
        }
      }
      
      function navigateToPath(pathStr) {
        // Navigate to a specific path from hash
        if (!pathStr) {
          navigateToRoot();
          return;
        }
        
        const segments = pathStr.split('/').filter(s => s.length > 0).map(decodeURIComponent);
        currentPath = [];
        currentItems = allItems;
        
        for (const segment of segments) {
          const dir = currentItems.find(item => item.type === 'directory' && item.name === segment);
          if (dir && dir.children) {
            currentPath.push(segment);
            currentItems = dir.children;
          } else {
            // Path not found, stop here
            break;
          }
        }
        
        search.value = '';
        apply();
      }
      
      function findMediaByPath(pathStr) {
        // Find a media item by its full path
        const flatItems = flattenAllItems(allItems);
        return flatItems.find(item => item.path === pathStr);
      }

      function render(list) {
        container.innerHTML = '';
        container.classList.toggle('list', viewMode === 'list');
        updateBreadcrumb();
        
        for (const it of list) {
          const card = document.createElement('div');
          card.className = 'card';
          
          if (it.type === 'directory') {
            // Render directory card
            const dirBtn = document.createElement('button');
            dirBtn.className = 'media directory-media';
            dirBtn.type = 'button';
            
            const icon = document.createElement('div');
            icon.className = 'directory-icon';
            icon.innerHTML = '<svg viewBox="0 0 24 24" width="64" height="64"><path d="M10 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2h-8l-2-2z" fill="currentColor"/></svg>';
            dirBtn.appendChild(icon);
            
            dirBtn.addEventListener('click', () => navigateInto(it.name));
            card.appendChild(dirBtn);
            
            const content = document.createElement('div');
            content.className = 'content';
            
            const title = document.createElement('div');
            title.className = 'title';
            const titleBtn = document.createElement('button');
            titleBtn.type = 'button';
            titleBtn.textContent = it.name;
            titleBtn.addEventListener('click', () => navigateInto(it.name));
            title.appendChild(titleBtn);
            
            const meta = document.createElement('div');
            meta.className = 'meta';
            const typeEl = document.createElement('span');
            typeEl.className = 'badge';
            typeEl.textContent = 'Folder';
            meta.appendChild(typeEl);
            
            content.appendChild(title);
            content.appendChild(meta);
            card.appendChild(content);
            container.appendChild(card);
          } else {
            // Render media card (existing logic)
            const media = document.createElement('button');
            media.className = 'media';
            media.type = 'button';
            const img = document.createElement('img');
            img.className = 'thumb';
            img.loading = 'lazy';
            const thumbSrc = pickThumb(it);
            const motionThumbSrc = it.motion_thumb;
            if (thumbSrc) {
              img.src = thumbSrc;
              img.alt = it.name || it.dir;
            } else {
              img.src = 'data:image/svg+xml;base64,' + btoa('<svg xmlns="http://www.w3.org/2000/svg" width="320" height="180" viewBox="0 0 320 180"><rect width="320" height="180" fill="#1f2937"/><text x="160" y="90" text-anchor="middle" fill="#9ca3af" font-family="system-ui" font-size="14">' + it.media_type + '</text></svg>');
              img.alt = it.name || it.dir;
            }
            media.appendChild(img);
            const overlay = document.createElement('div');
            overlay.className = 'play';
            overlay.innerHTML = '<div class="play-icon">' + getMediaIcon(it.media_type) + '</div>';
            media.appendChild(overlay);

            if (motionThumbSrc && thumbSrc) {
              const motionVideo = document.createElement('video');
              motionVideo.className = 'motion-thumb';
              motionVideo.src = motionThumbSrc;
              motionVideo.muted = true;
              motionVideo.loop = true;
              motionVideo.preload = 'none';
              media.appendChild(motionVideo);

              media.addEventListener('mouseenter', () => {
                motionVideo.style.opacity = '1';
                motionVideo.play().catch(() => {});
              });

              media.addEventListener('mouseleave', () => {
                motionVideo.style.opacity = '0';
                motionVideo.pause();
                motionVideo.currentTime = 0;
              });
            }
            if (it.primary_media) {
              if (it.media_type === 'image') {
                media.addEventListener('click', () => openImageViewer(it.primary_media, it.name || it.dir));
              } else {
                media.addEventListener('click', () => openPlayer(it, it.name || it.dir, it.media_type));
              }
            }
            card.appendChild(media);

            const content = document.createElement('div');
            content.className = 'content';
            const title = document.createElement('div');
            title.className = 'title';
            if (it.primary_media) {
              const tbtn = document.createElement('button');
              tbtn.type = 'button';
              tbtn.textContent = it.name || it.dir;
              if (it.media_type === 'image') {
                tbtn.addEventListener('click', () => openImageViewer(it.primary_media, it.name || it.dir));
              } else {
                tbtn.addEventListener('click', () => openPlayer(it, it.name || it.dir, it.media_type));
              }
              title.appendChild(tbtn);
            } else {
              title.textContent = it.name || it.dir;
            }
            const meta = document.createElement('div');
            meta.className = 'meta';
            const typeEl = document.createElement('span');
            typeEl.className = 'badge';
            typeEl.textContent = it.media_type.charAt(0).toUpperCase() + it.media_type.slice(1);
            const dateEl = document.createElement('span');
            dateEl.className = 'badge';
            dateEl.textContent = fmtDate(it.created_time);
            const sizeEl = document.createElement('span');
            sizeEl.className = 'badge';
            sizeEl.textContent = fmtSize(it.size);
            const subtitleEl = document.createElement('span');
            subtitleEl.className = 'badge';
            subtitleEl.textContent = 'CC';
            subtitleEl.title = 'Has subtitles';
            if (typeEl.textContent) meta.appendChild(typeEl);
            if (dateEl.textContent) meta.appendChild(dateEl);
            if (sizeEl.textContent) meta.appendChild(sizeEl);
            if (it.subtitles && it.subtitles.length > 0) meta.appendChild(subtitleEl);
            const row = document.createElement('div');
            row.className = 'row';
            if (it.analytics) { const a = document.createElement('a'); a.href = it.analytics; a.className='btn'; a.textContent='Analytics JSON'; row.appendChild(a); }
            if (it.metadata) { const a = document.createElement('a'); a.href = it.metadata; a.className='btn'; a.textContent='Metadata JSON'; row.appendChild(a); }
            content.appendChild(title);
            content.appendChild(meta);
            if (row.children.length) content.appendChild(row);
            card.appendChild(content);
            container.appendChild(card);
          }
        }
      }

      function sortItems(list) {
        const arr = [...list];
        const dir = sortDir === 'asc' ? 1 : -1;
        
        // Sort directories first, then media items
        arr.sort((a, b) => {
          // Directories always come before media when not searching
          if (a.type === 'directory' && b.type !== 'directory') return -1;
          if (a.type !== 'directory' && b.type === 'directory') return 1;
          
          if (sortKey === 'alpha') {
            const an = (a.name || '').toLowerCase();
            const bn = (b.name || '').toLowerCase();
            if (an < bn) return -1 * dir; if (an > bn) return 1 * dir; return 0;
          } else if (sortKey === 'size') {
            const av = a.size || 0; const bv = b.size || 0; return (av - bv) * dir;
          } else if (sortKey === 'date') {
            const at = a.created_time ? Date.parse(a.created_time) : 0;
            const bt = b.created_time ? Date.parse(b.created_time) : 0;
            return (at - bt) * dir;
          } else if (sortKey === 'type') {
            const at = a.media_type || '';
            const bt = b.media_type || '';
            if (at < bt) return -1 * dir; if (at > bt) return 1 * dir; return 0;
          }
          return 0;
        });
        return arr;
      }

      function extractVideoId(dirName) {
        const match = dirName.match(/ - (\d+)$/);
        return match ? match[1] : '';
      }

      // Flatten entire tree for search
      function flattenAllItems(items) {
        let flat = [];
        for (const item of items) {
          if (item.type === 'media') {
            flat.push(item);
          } else if (item.type === 'directory' && item.children) {
            flat = flat.concat(flattenAllItems(item.children));
          }
        }
        return flat;
      }

      function apply() {
        const q = search.value.toLowerCase().trim();
        let filtered;

        if (!q) {
          // No search query, show current directory items
          filtered = currentItems;
        } else {
          // When searching, flatten all items and search across entire library
          const allFlatItems = flattenAllItems(allItems);
          
          // If subtitle index isn't loaded, fetch it in the background (only once)
          if (!searchIndex.subtitle_terms) searchIndex.subtitle_terms = {};
          if (Object.keys(searchIndex.subtitle_terms).length === 0 && !subtitlesLoading) {
            subtitlesLoading = true;
            fetchJSON('index.subtitles.json')
              .then(subs => {
                searchIndex.subtitle_terms = subs.subtitle_terms || {};
                apply();
              })
              .catch(() => {
                // If subtitle index doesn't exist or fails to load, that's okay
                subtitlesLoading = false;
              });
          }
          
          // Use search index for efficient filtering
          if (searchIndex.item_map && searchIndex.item_map.length > 0) {
            const matchingIndices = new Set();

            for (const term in searchIndex.name_terms) {
              if (term.includes(q)) {
                searchIndex.name_terms[term].forEach(idx => matchingIndices.add(idx));
              }
            }

            for (const term in searchIndex.description_terms) {
              if (term.includes(q)) {
                searchIndex.description_terms[term].forEach(idx => matchingIndices.add(idx));
              }
            }

            if (searchIndex.subtitle_terms) {
              for (const term in searchIndex.subtitle_terms) {
                if (term.includes(q)) {
                  searchIndex.subtitle_terms[term].forEach(idx => matchingIndices.add(idx));
                }
              }
            }

            filtered = Array.from(matchingIndices).map(idx => allFlatItems[idx]).filter(Boolean);
          } else {
            // Fallback to direct search
            filtered = allFlatItems.filter(it => {
              const name = (it.name || '').toLowerCase();
              const path = (it.path || '').toLowerCase();
              const type = (it.media_type || '').toLowerCase();
              const description = (it.description || '').toLowerCase();

              return name.includes(q) ||
                     path.includes(q) ||
                     type.includes(q) ||
                     description.includes(q);
            });
          }
        }

        const sorted = sortItems(filtered);
        render(sorted);
      }

      // Initialize controls
      apply();
      search.addEventListener('input', () => {
        apply();
      });
      sortSel.addEventListener('change', () => { sortKey = sortSel.value; apply(); });
      dirBtn.addEventListener('click', () => {
        sortDir = (sortDir === 'asc') ? 'desc' : 'asc';
        dirBtn.textContent = (sortDir === 'asc') ? 'Ascending' : 'Descending';
        apply();
      });
      viewBtn.addEventListener('click', () => {
        viewMode = (viewMode === 'grid') ? 'list' : 'grid';
        viewBtn.textContent = viewMode === 'grid' ? 'Grid' : 'List';
        apply();
      });

      // Modal wiring
      const modal = document.getElementById('playerModal');
      const modalTitle = document.getElementById('playerTitle');
      const mediaEl = document.getElementById('playerMedia');
      const closeBtn = document.getElementById('playerClose');
      function close() {
        modal.classList.remove('open');
        // Stop playback and release resource
        if (mediaEl.tagName === 'VIDEO' || mediaEl.tagName === 'AUDIO') {
          mediaEl.pause();
          mediaEl.removeAttribute('src');
          mediaEl.load();
        }
        
        // Clear the media hash from URL
        const hash = window.location.hash;
        if (hash && hash !== '#') {
          const mediaItem = findMediaByPath(hash.substring(1));
          if (mediaItem) {
            // Go back to the directory containing this media
            const pathParts = mediaItem.path.split('/');
            pathParts.pop(); // Remove filename
            if (pathParts.length > 0) {
              window.location.hash = '#' + pathParts.join('/');
            } else {
              window.location.hash = '';
            }
          }
        }
      }
      closeBtn.addEventListener('click', close);
      modal.addEventListener('click', (e) => { if (e.target === modal) close(); });
      window.addEventListener('keydown', (e) => { 
        if (e.key === 'Escape') {
          if (immersive.classList.contains('open')) {
            closeImmersive();
          } else if (modal.classList.contains('open')) {
            close();
          }
        }
      });

      // Immersive player elements
      const immersive = document.getElementById('immersive');
      const immTitle = document.getElementById('immersiveTitle');
      const immMedia = document.getElementById('immersiveMedia');
      const immInfo = document.getElementById('immersiveInfo');
  const immClose = document.getElementById('immersiveClose');
  const qWrap = document.getElementById('qualityControls');

      function isDesktop() {
        return window.matchMedia('(min-width: 1024px)').matches && window.matchMedia('(pointer: fine)').matches;
      }

      function openImmersive(item, title, type) {
        document.body.classList.add('immersive-open');
        immTitle.textContent = title || 'Media';
        immMedia.innerHTML = '';
        immInfo.innerHTML = '';
        const hasOptimized = !!item.transcoded;
        const hasOriginal = !!item.primary_media;
        let currentQuality = hasOptimized ? 'optimized' : 'original';
        const pickSrc = () => (currentQuality === 'optimized' ? item.transcoded : item.primary_media) || item.primary_media || item.transcoded;
        const src = pickSrc();
        if (type === 'video') {
          const video = document.createElement('video');
          video.setAttribute('controls', '');
          video.setAttribute('preload', 'metadata');
          video.setAttribute('autoplay', '');
          video.src = src;
          immMedia.appendChild(video);
          // Enable loop for videos shorter than 1 minute
          video.addEventListener('loadedmetadata', () => {
            if (video.duration && video.duration < 60) {
              video.setAttribute('loop', '');
            }
          });
        } else if (type === 'audio') {
          const audio = document.createElement('audio');
          audio.setAttribute('controls', '');
          audio.setAttribute('preload', 'metadata');
          audio.style.width = '100%';
          audio.src = src;
          immMedia.appendChild(audio);
        } else if (type === 'image') {
          const img = document.createElement('img');
          img.alt = title || 'Image';
          img.src = src;
          immMedia.appendChild(img);
        }

        // Build quality controls (for video/audio)
        if (qWrap) {
          qWrap.innerHTML = '';
          if ((type === 'video' || type === 'audio') && (hasOptimized || hasOriginal)) {
            const makeBtn = (label, q) => {
              const b = document.createElement('button');
              b.type = 'button';
              b.className = 'btn';
              b.textContent = label;
              b.addEventListener('click', () => {
                if (currentQuality === q) return;
                const media = immMedia.querySelector(type);
                if (!media) return;
                const t = media.currentTime || 0;
                currentQuality = q;
                media.pause();
                media.src = pickSrc();
                try { media.currentTime = t; } catch {}
                media.play().catch(() => {});
                updateActive();
              });
              return b;
            };
            const updateActive = () => {
              [...qWrap.querySelectorAll('button')].forEach(btn => btn.classList.remove('active'));
              const target = currentQuality === 'optimized' ? btnOpt : btnOrig;
              if (target) target.classList.add('active');
            };
            let btnOpt = null, btnOrig = null;
            if (hasOptimized) btnOpt = makeBtn('Optimized', 'optimized');
            if (hasOriginal) btnOrig = makeBtn('Original', 'original');
            if (btnOpt) qWrap.appendChild(btnOpt);
            if (btnOrig) qWrap.appendChild(btnOrig);
            updateActive();
            qWrap.style.display = (hasOptimized && hasOriginal) ? 'flex' : 'none';
          } else {
            qWrap.style.display = 'none';
          }
        }

        // Build metadata/details
        const meta = document.createElement('div');
        meta.className = 'meta';
        const typeEl = document.createElement('span'); typeEl.className = 'badge'; typeEl.textContent = (item.media_type||'').replace(/^./, c=>c.toUpperCase());
        const dateEl = document.createElement('span'); dateEl.className = 'badge'; dateEl.textContent = fmtDate(item.created_time);
        const sizeEl = document.createElement('span'); sizeEl.className = 'badge'; sizeEl.textContent = fmtSize(item.size);
        const subtitleEl = document.createElement('span'); subtitleEl.className = 'badge'; subtitleEl.textContent = 'CC'; subtitleEl.title = 'Has subtitles';
  if (typeEl.textContent) meta.appendChild(typeEl);
  if (dateEl.textContent) meta.appendChild(dateEl);
  if (sizeEl.textContent) meta.appendChild(sizeEl);
  if (item.subtitles && item.subtitles.length > 0) meta.appendChild(subtitleEl);

        const links = document.createElement('div');
        links.className = 'row';
        if (item.analytics) { const a = document.createElement('a'); a.href = item.analytics; a.className='btn'; a.textContent='Analytics JSON'; links.appendChild(a); }
        if (item.metadata) { const a = document.createElement('a'); a.href = item.metadata; a.className='btn'; a.textContent='Metadata JSON'; links.appendChild(a); }

        const wrap = document.createElement('div');
        const heading = document.createElement('div'); heading.className='title'; heading.textContent = title || 'Media';
        wrap.appendChild(heading);
        wrap.appendChild(meta);
        
        // Add description if available
        if (item.description) {
          const descEl = document.createElement('p');
          descEl.style.marginTop = '12px';
          descEl.style.lineHeight = '1.5';
          descEl.textContent = item.description;
          wrap.appendChild(descEl);
        }
        
        // Add download button for original file
        if (item.primary_media || item.transcoded) {
          const downloadBtn = document.createElement('a');
          downloadBtn.href = item.primary_media || item.transcoded;
          downloadBtn.download = '';
          downloadBtn.className = 'btn';
          downloadBtn.style.marginTop = '12px';
          downloadBtn.style.display = 'inline-block';
          downloadBtn.textContent = 'â¬‡ Download Original';
          downloadBtn.title = 'Download the original file';
          wrap.appendChild(downloadBtn);
        }
        
        if (links.children.length) wrap.appendChild(links);
        immInfo.appendChild(wrap);

        // Load and render transcript if subtitles are available (check for existing transcript to prevent duplicates)
        if (item.subtitles && item.subtitles.length > 0 && !immInfo.querySelector('.transcript-panel')) {
          console.log('Loading transcript for:', item);
          loadTranscript(item, immInfo, type);
        } else if (item.subtitles && immInfo.querySelector('.transcript-panel')) {
          console.log('Transcript already loaded for:', item.path);
        } else {
          console.log('No subtitles available for this item:', item);
        }

        immersive.classList.add('open');
      }

      async function loadTranscript(item, container, mediaType) {
        console.log('loadTranscript called with item:', item);
        try {
          // Get subtitle file from item
          if (!item.subtitles || item.subtitles.length === 0) {
            console.log('No subtitle files found for this item');
            return;
          }

          // For now, use the first subtitle track (could be extended to support multiple languages)
          const subtitleInfo = item.subtitles[0];
          const subtitlePath = subtitleInfo.file;
          
          console.log('Fetching subtitle file:', subtitlePath);
          
          // Fetch and parse the SRT file
          const subtitleEntries = await parseSRTFile(subtitlePath);
          
          if (!subtitleEntries || subtitleEntries.length === 0) {
            console.log('No subtitle entries found in file:', subtitlePath);
            return;
          }

          // Create transcript panel
          const panel = document.createElement('div');
          panel.className = 'transcript-panel';
          
          // Header
          const header = document.createElement('div');
          header.className = 'transcript-header';
          
          const titleDiv = document.createElement('div');
          titleDiv.className = 'transcript-title';
          titleDiv.textContent = 'Transcript (' + subtitleEntries.length + ')';
          
          header.appendChild(titleDiv);
          
          // Search box
          const searchBox = document.createElement('div');
          searchBox.className = 'transcript-search';
          const searchInput = document.createElement('input');
          searchInput.type = 'text';
          searchInput.placeholder = 'Filter...';
          searchBox.appendChild(searchInput);
          
          // Body with segments
          const body = document.createElement('div');
          body.className = 'transcript-body';
          
          const segments = document.createElement('div');
          segments.className = 'transcript-segments';
          
          // Render segments
          subtitleEntries.forEach((entry, index) => {
            const segmentDiv = document.createElement('div');
            segmentDiv.className = 'transcript-segment';
            segmentDiv.dataset.index = index;
            segmentDiv.dataset.text = entry.text.toLowerCase();
            
            const timestampDiv = document.createElement('div');
            timestampDiv.className = 'transcript-timestamp';
            timestampDiv.textContent = formatTranscriptTime(entry.start);
            
            const textDiv = document.createElement('div');
            textDiv.className = 'transcript-text';
            textDiv.textContent = entry.text;
            
            segmentDiv.appendChild(timestampDiv);
            segmentDiv.appendChild(textDiv);
            
            // Click to jump to timestamp
            segmentDiv.addEventListener('click', () => {
              const mediaElement = immMedia.querySelector('video, audio');
              if (mediaElement && entry.start) {
                const seconds = parseSubtitleTimestamp(entry.start);
                mediaElement.currentTime = seconds;
                mediaElement.play().catch(() => {});
                
                // Highlight active segment
                segments.querySelectorAll('.transcript-segment').forEach(s => s.classList.remove('active'));
                segmentDiv.classList.add('active');
              }
            });
            
            segments.appendChild(segmentDiv);
          });
          
          body.appendChild(segments);
          
          // Assemble panel
          panel.appendChild(header);
          panel.appendChild(searchBox);
          panel.appendChild(body);
          
          container.appendChild(panel);
          
          // Search functionality
          searchInput.addEventListener('input', () => {
            const query = searchInput.value.toLowerCase().trim();
            
            segments.querySelectorAll('.transcript-segment').forEach(segment => {
              const text = segment.dataset.text;
              
              if (!query || text.includes(query)) {
                segment.classList.remove('hidden');
                
                // Highlight matching text
                if (query) {
                  const textDiv = segment.querySelector('.transcript-text');
                  const originalText = subtitleEntries[segment.dataset.index].text;
                  const regex = new RegExp('(' + escapeRegex(query) + ')', 'gi');
                  textDiv.innerHTML = originalText.replace(regex, '<mark>$1</mark>');
                } else {
                  const textDiv = segment.querySelector('.transcript-text');
                  textDiv.textContent = subtitleEntries[segment.dataset.index].text;
                }
              } else {
                segment.classList.add('hidden');
              }
            });
          });
          
          // Auto-scroll and highlight transcript during playback
          const mediaElement = immMedia.querySelector('video, audio');
          if (mediaElement) {
            mediaElement.addEventListener('timeupdate', () => {
              const currentTime = mediaElement.currentTime;
              
              // Find the active segment based on current playback time
              let activeSegment = null;
              for (let i = 0; i < subtitleEntries.length; i++) {
                const entry = subtitleEntries[i];
                const startTime = parseSubtitleTimestamp(entry.start);
                const endTime = parseSubtitleTimestamp(entry.end);
                
                if (currentTime >= startTime && currentTime <= endTime) {
                  activeSegment = segments.children[i];
                  break;
                }
              }
              
              // Update active class
              segments.querySelectorAll('.transcript-segment').forEach(s => s.classList.remove('active'));
              
              if (activeSegment && !activeSegment.classList.contains('hidden')) {
                activeSegment.classList.add('active');
                
                // Auto-scroll to keep active segment visible
                const bodyRect = body.getBoundingClientRect();
                const segmentRect = activeSegment.getBoundingClientRect();
                
                // Check if segment is out of view
                if (segmentRect.top < bodyRect.top || segmentRect.bottom > bodyRect.bottom) {
                  activeSegment.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
              }
            });
          }
          
        } catch (error) {
          console.warn('Failed to load transcript:', error);
        }
      }

      function formatTranscriptTime(timestamp) {
        // Convert timestamp from SRT format (00:00:01,000) or VTT format (00:00:01.000) to display format (0:01)
        if (!timestamp) return '';
        
        // Handle both comma and period as decimal separator
        const normalized = timestamp.replace(',', '.');
        const parts = normalized.split(':');
        
        if (parts.length === 3) {
          const hours = parseInt(parts[0], 10);
          const minutes = parseInt(parts[1], 10);
          const seconds = parseInt(parts[2].split('.')[0], 10);
          
          if (hours > 0) {
            return hours + ':' + minutes.toString().padStart(2, '0') + ':' + seconds.toString().padStart(2, '0');
          } else {
            return minutes + ':' + seconds.toString().padStart(2, '0');
          }
        }
        
        return timestamp;
      }

      function parseSubtitleTimestamp(timestamp) {
        // Convert SRT/VTT timestamp to seconds
        if (!timestamp) return 0;
        
        // Handle both comma and period as decimal separator
        const normalized = timestamp.replace(',', '.');
        const parts = normalized.split(':');
        
        if (parts.length === 3) {
          const hours = parseInt(parts[0], 10);
          const minutes = parseInt(parts[1], 10);
          const secondsParts = parts[2].split('.');
          const seconds = parseInt(secondsParts[0], 10);
          const milliseconds = secondsParts[1] ? parseInt(secondsParts[1], 10) / 1000 : 0;
          
          return hours * 3600 + minutes * 60 + seconds + milliseconds;
        }
        
        return 0;
      }

      async function parseSRTFile(srtPath) {
        // Fetch and parse an SRT file
        try {
          const response = await fetch(srtPath);
          if (!response.ok) {
            console.error('Failed to fetch SRT file:', srtPath);
            return null;
          }
          
          const content = await response.text();
          const subtitles = [];
          
          // Split into blocks (entries separated by blank lines)
          const blocks = content.trim().split(/\n\s*\n/);
          
          for (const block of blocks) {
            const lines = block.trim().split('\n');
            if (lines.length < 3) continue; // Need at least: number, timestamp, text
            
            // First line is the sequence number (skip it)
            // Second line is the timestamp
            const timestampLine = lines[1];
            const timestampMatch = timestampLine.match(/(\d{2}:\d{2}:\d{2}[,\.]\d{3})\s*-->\s*(\d{2}:\d{2}:\d{2}[,\.]\d{3})/);
            
            if (!timestampMatch) continue;
            
            const startTime = timestampMatch[1];
            const endTime = timestampMatch[2];
            
            // Rest of the lines are the subtitle text
            const text = lines.slice(2).join(' ').trim();
            
            if (text) {
              subtitles.push({
                start: startTime,
                end: endTime,
                text: text
              });
            }
          }
          
          return subtitles;
        } catch (error) {
          console.error('Error parsing SRT file:', error);
          return null;
        }
      }

      function escapeRegex(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      }

      function closeImmersive() {
        document.body.classList.remove('immersive-open');
        // Stop playback and release resource
        const media = immMedia.querySelector('video, audio');
        if (media) { try { media.pause(); } catch(e){} media.removeAttribute('src'); media.load && media.load(); }
        immersive.classList.remove('open');
        
        // Update hash to directory path when closing
        const hash = window.location.hash;
        if (hash && hash !== '#') {
          // If the hash was a media file path, revert to directory view
          const mediaItem = findMediaByPath(hash.substring(1));
          if (mediaItem) {
            // Go back to the directory containing this media
            const pathParts = mediaItem.path.split('/');
            pathParts.pop(); // Remove filename
            suppressHashChange = true;
            if (pathParts.length > 0) {
              window.location.hash = '#' + pathParts.join('/');
            } else {
              window.location.hash = '';
            }
            setTimeout(() => { suppressHashChange = false; }, 10);
            // Manually navigate since we're suppressing hashchange
            navigateToPath(pathParts.join('/'));
          }
        }
      }
      immClose.addEventListener('click', closeImmersive);

      // Track if we're programmatically changing the hash to avoid double-opening
      let suppressHashChange = false;

      window.openPlayer = (item, title, type) => {
        // Update hash with media path
        if (item.path) {
          suppressHashChange = true;
          window.location.hash = '#' + item.path;
          // Reset flag after a small delay to allow hashchange to fire and be ignored
          setTimeout(() => { suppressHashChange = false; }, 10);
        }
        // Always use immersive view for consistent UI and quality control
        openImmersive(item, title, type);
      };

      window.openImageViewer = (src, title) => {
        // For images, we need to find the item to get its path
        const flatItems = flattenAllItems(allItems);
        const item = flatItems.find(it => it.primary_media === src);
        
        if (item && item.path) {
          window.location.hash = '#' + item.path;
        }
        
        if (isDesktop()) {
          modalTitle.textContent = title || 'Image';
          mediaEl.innerHTML = '<img class="modal-image" alt="' + (title || 'Image') + '">';
          const img = mediaEl.querySelector('img');
          img.setAttribute('src', src);
          modal.classList.add('open');
        } else {
          const itemObj = item || { primary_media: src, media_type: 'image' };
          openImmersive(itemObj, title || 'Image', 'image');
        }
      };
      
      // Handle hash changes (browser back/forward)
      window.addEventListener('hashchange', () => {
        // Ignore hash changes that we triggered ourselves
        if (suppressHashChange) {
          return;
        }
        
        const hash = decodeURIComponent(window.location.hash.substring(1)); // Remove the '#' and decode
        
        // Check if it's a media file path
        const mediaItem = findMediaByPath(hash);
        if (mediaItem) {
          // Open the media player
          openPlayer(mediaItem, mediaItem.name || mediaItem.dir, mediaItem.media_type);
        } else {
          // It's a directory path
          navigateToPath(hash);
        }
      });
      
      // On initial load, check if there's a hash and navigate to it
      const initialHash = decodeURIComponent(window.location.hash.substring(1));
      if (initialHash) {
        const mediaItem = findMediaByPath(initialHash);
        if (mediaItem) {
          // It's a media file, open it
          openPlayer(mediaItem, mediaItem.name || mediaItem.dir, mediaItem.media_type);
        } else {
          // It's a directory, navigate to it
          navigateToPath(initialHash);
        }
      }
    }

    window.addEventListener('DOMContentLoaded', load);
  </script>
</head>
<body>
  <div class="app">
    <nav class="nav" aria-label="Library controls">
      <div class="brand">
        <span class="brand-title">Media Library</span>
      </div>
      <div class="controls">
        <label for="search" class="visually-hidden">Search</label>
  <input id="search" class="input" placeholder="Search media, subtitles, descriptions..." />
        <div class="row">
          <label for="sort" class="visually-hidden">Sort by</label>
          <select id="sort" class="select">
            <option value="date" selected>Date</option>
            <option value="alpha">Alphabetical</option>
            <option value="size">Size</option>
            <option value="type">Type</option>
          </select>
          <button id="direction" class="btn" aria-pressed="false">Descending</button>
          <button id="view" class="btn" aria-pressed="false">Grid</button>
        </div>
      </div>
    </nav>
    <main class="main" role="main">
      <div id="breadcrumb" class="breadcrumb" style="padding: 12px 18px 0 18px;"></div>
      <div class="container"></div>
    </main>
  </div>

  <!-- Modal media player/viewer -->
  <div id="playerModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="playerTitle">
    <div class="modal-dialog">
      <div class="modal-header">
        <div id="playerTitle" class="modal-title">Media</div>
        <button id="playerClose" class="modal-close" aria-label="Close">Ã—</button>
      </div>
      <div id="playerMedia" class="modal-body">
      </div>
    </div>
  </div>

    <!-- Immersive player for mobile/tablets -->
    <div id="immersive" class="immersive" aria-hidden="true">
      <div class="immersive-header">
        <button id="immersiveClose" class="immersive-close" aria-label="Close">Back</button>
        <div id="immersiveTitle" class="immersive-title">Media</div>
        <div id="qualityControls" class="quality" style="display:none"></div>
      </div>
      <div class="immersive-content">
        <div id="immersiveMedia" class="immersive-media"></div>
        <div id="immersiveInfo" class="immersive-info"></div>
      </div>
    </div>
</body>
</html>
